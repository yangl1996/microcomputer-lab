STACK SEGMENT PARA STACK
	DW 128H DUP(0)
STACK ENDS

DATA SEGMENT
	START_MSG DB 'SLIP CLIENT$'
	FILENAME DB 'SLIP_OUT.TXT', 0
	OUTFILENAME DB 'OUT.FILE', 0
	TXLEN DW 0
	TXBUF DB 128H DUP(0)
	RXLEN DW 0
	RXBUF DB 128H DUP(0)
	FILELEN DW 0
	FILEBUF DB 128H DUP(0)
	RXESC DB 0
	RXEND DB 0
	
DATA ENDS

CODE SEGMENT
	ASSUME CS:CODE, SS:STACK, DS:DATA
START:
	MOV AX, DATA
	MOV DS, AX
	
	CALL INITDEVICE
	MOV TXLEN, 100
	CALL SENDDATA
	CALL SAVETOFILE
	CALL CLEANUP
	MOV AH, 4CH
	INT 21H

SENDLAYER3 PROC NEAR
	; SEND A FILE USING LAYER3
	; 00H OR 0AAH (ENDING PACKET) | PAYLOAD
	PUSH AX
	PUSH DX
	PUSH BX
	PUSH CX

	LEA DX, OUTFILENAME
	MOV AL, 0
	MOV AH, 3DH
	INT 21H			; OPEN FILE FOR READING
	MOV BX, AX
	LEA DX, TXBUF
	ADD DX, 1
READFILETOBUFFER:
	MOV CX, 512		; TRY TO READ 512 BYTES
	MOV AH, 3FH
	INT 21H
	CMP AX, 512
	JL LASTFRAME	; IF LENGTH SMALLER THAN 512, IT'S LAST FRAME
	MOV TXLEN, AX
	ADD TXLEN, 1
	MOV TXBUF, 00H	; SET IT'S NOT LAST FRAME
	CALL SENDLAYER2
	JMP READFILETOBUFFER
LASTFRAME:
	MOV TXLEN, AX
	ADD TXLEN, 1
	MOV TXBUF, 0AAH	; SET IT'S LAST FRAME
	CALL SENDLAYER2
	MOV AH, 3EH
	INT 21H			; CLOSE FILE
	POP CX
	POP BX
	POP DX
	POP AX
	RET
SENDLAYER3 ENDP

RECEIVELAYER3 PROC NEAR
RECEIVELAYER3 ENDP

SENDLAYER2 PROC NEAR
	PUSH AX
	PUSH DX
	; SEND A LAYER2 FRAME, INCLUDING BASIC LAYER 2 FUNCTIONS
	; PAYLOAD AND LENGTH SHOULD BE LOADED INTO BUFFER BEFOREHAND
	; FRAME FORMAT, UNIT IS BYTE
	; 1 END | <=128 PAYLOAD | 1 END | >=64 GAP (0x00)
	CALL SENDDATA		; SEND CONTENT IN BUFFER WITH END SIG
	MOV AH, 64
	MOV AL, 0
	MOV DX, 0E4B8H
STARTSENDGAP:
	CMP AH, 0			; WE SEND 64 GAP BYTES
	JE ENDSENDGAP
	OUT DX, AH			; SEND A GAP BYTE
	SUB AH, 1
	JMP STARTSENDGAP
ENDSENDGAP:
	POP DX
	POP AX
	RET
SENDLAYER2 ENDP

RECEIVELAYER2 PROC NEAR
	; RECEIVE A LAYER2 FRAME IN A BLOCKING BEHAVIOR
	; WHEN FUNCTION RETURNS, RECEIVED DATA WILL BE IN BUFFER
	PUSH AX
	PUSH DX
WAITFORSTARTSIG:
	CMP RXEND, 1
	JNE WAITFORSTARTSIG
	MOV RXEND, 0
	MOV RXLEN, 0
	MOV RXESC, 0
WAITFORENDSIG:
	CMP RXEND, 1
	JNE WAITFORENDSIG
	MOV RXEND, 0
	MOV RXESC, 0
	POP DX
	POP AX
	RET
RECEIVELAYER2 ENDP

SENDDATA PROC NEAR
	; TXLEN HOLDS DATA LENGTH, TXBUF HOLDS BUFFER
	PUSH DX
	PUSH AX
	PUSH SI
	PUSH BX
	LEA BX, TXBUF		; BX HOLDS BUFFER START ADDRESS
	MOV SI, 0			; SI HOLDS OFFSET
	CALL SENDSIGEND
SENDSTART:
	CMP TXLEN, 0
	JZ SENDEND
	MOV DX, 0E4B9H
WAITSEND:
	IN AL, DX			; CHECK PORT STATUS
	AND AL, 1			; CHECK TXRDY
	CMP AL, 1
	JNE WAITSEND		; IF NOT READY, GO BACK
	; SEND A BYTE
	MOV DX, 0E4B8H
	MOV AL, [BX+SI]
TXENDECSAPE:
	CMP AL, 0C0H		; CHECK END BYTE
	JNE TXESCESCAPE
	MOV AL, 0DBH		; IF END OCCURS, SEND AN ESC FIRST
	MOV AH, 0DCH
	MOV [BX+SI], AH		; NEXT WE SEND AN ESCAPED END
	ADD TXLEN, 1
	SUB SI, 1			; NEXT TIME WE STILL SEND THIS POSITION
	JMP TXESCAPEDONE	
TXESCESCAPE:
	CMP AL, 0DBH		; CHECK ESC BYTE
	JNE TXESCAPEDONE
	MOV AH, 0DDH
	MOV [BX+SI], AH		; NEXT WE SEND AN ESCAPED ESC
	ADD TXLEN, 1
	SUB SI, 1			; NEXT TIME WE STILL SEND THIS POSITION
TXESCAPEDONE:
	OUT DX, AL			; SEND OUT DATA
	SUB TXLEN, 1
	ADD SI, 1			; MOVE OFFSET
	JMP SENDSTART
SENDEND:
	CALL SENDSIGEND
	POP BX
	POP SI
	POP AX
	POP DX
	RET
SENDDATA ENDP

SENDSIGEND PROC NEAR
	; SEND AN END SIGNAL
	PUSH AX
	PUSH DX
	MOV DX, 0E4B9H
WAITSEND_SENDSIGEND:
	IN AL, DX			; CHECK PORT STATUS
	AND AL, 1			; CHECK TXRDY
	CMP AL, 1
	JNE WAITSEND_SENDSIGEND		; IF NOT READY, GO BACK
	MOV DX, 0E4B8H
	MOV AL, 0C0H
	OUT DX, AL
	POP DX
	POP AX
	RET
SENDSIGEND ENDP

SAVETOFILE PROC NEAR
	; SAVE CONTENT IN FILEBUFFER
	PUSH AX
	PUSH BX
	PUSH CX
	PUSH DX
	MOV CX, 0
	LEA DX, FILENAME
	MOV AH, 3CH
	INT 21H				; CREATE FILE
	LEA DX, FILEBUF
	MOV BX, AX
	MOV CX, FILELEN
	MOV AH, 40H
	INT 21H				; WRITE TO FILE
	MOV AH, 3EH
	INT 21H
	POP DX
	POP CX
	POP BX
	POP AX
	RET
SAVETOFILE ENDP

INITDEVICE PROC NEAR
	PUSH DX
	PUSH AX
	PUSH DS
	; CONFIGURE IRQ
	MOV AX, CS
	MOV DS, AX
	MOV DX, OFFSET IRQ
	MOV AX, 250EH
	INT 21H
	CLI
	MOV DX, 0EC4CH
	MOV AL, 43H
	OUT DX, AL
	INC DX
	MOV AL, 1DH
	OUT DX, AL
	IN AL, 21H
	AND AL, 10111111B
	OUT 21H, AL
	STI

	; CONFIGURE SERIAL PORT
	MOV DX, 0E4B9H
	MOV AL, 0
	OUT DX, AL
	OUT DX, AL
	OUT DX, AL
	MOV AL, 40H
	OUT DX, AL
	MOV AL, 4EH
	OUT DX, AL
	MOV AL, 27H
	OUT DX, AL

	; CONFIGURE CLOCK
	MOV DX, 0E483H
	MOV AL, 01010110B	; WE ARE USING CHANNEL 1
	OUT DX, AL
	MOV DX, 0E481H
	MOV AL, 52
	OUT DX, AL
	POP DS
	POP AX
	POP DX
	RET
INITDEVICE ENDP

CLEANUP PROC NEAR
	PUSH DX
	PUSH AX
	IN AL, 21H
	OR AL, 40H
	OUT 21H, AL
	MOV DX, 0EC4CH
	MOV AL, 42H
	OUT DX, AL
	STI
	POP AX
	POP DX
	RET
CLEANUP ENDP

IRQ PROC FAR
	PUSH AX
	PUSH DX
	PUSH DS
	PUSH BX
	PUSH DI

	MOV AX, DATA
	MOV DS, AX			; SET DATA SEGMENT
	MOV DX, 0E4B8H
	IN AL, DX			; READ DATA FROM SERIAL PORT
CHECKRXEND:
	CMP AL, 0C0H
	JNE CHECKRXESC
	MOV RXEND, 1		; IF RECEIVED END SIGN, SET END BIT
	JMP ENDIRQRX
CHECKRXESC:
	CMP AL, 0DBH
	JNE	NORMAL
	MOV RXESC, 1		; IF RECEIVED ESC SIGN, SET ESC BIT
	JMP ENDIRQRX
NORMAL:
CHECKESCAPED:
	CMP RXESC, 1
	JNE NOTESCAPED
	MOV RXESC, 0		; IF GOT A ESC SIGN EARLIER
	CMP AL, 0DCH
	JE RXESCAPEDEND
RXESCAPEDESC:			; ESCAPED ESC
	MOV AL, 0DBH
	JMP NOTESCAPED
RXESCAPEDEND:			; ESCAPED END
	MOV AL, 0C0H
NOTESCAPED:
	; SAVE AL TO RX BUFFER
	MOV DI, RXLEN
	LEA BX, RXBUF
	MOV [BX+DI], AL		; SAVE DATA TO MEMORY
	ADD DI, 1
	MOV RXLEN, DI

ENDIRQRX:
	MOV AL, 20H
	OUT 20H, AL
	MOV DX, 0EC4DH
	MOV AL, 1DH
	OUT DX, AL
	POP DI
	POP BX
	POP DS
	POP DX
	POP AX
	IRET
IRQ ENDP

CODE ENDS
END START
